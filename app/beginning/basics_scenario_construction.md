# Инструментарий проектирования

***Решение*** в терминологии Loginom - комплекс сценариев, файлов, источников данных и прочих элементов, предназначенных для решения отдельной аналитической задачи. *Решение* может объединять в себе несколько пакетов благодаря тому, что каждый пакет имеет возможность предоставлять свои объекты другим пакетам через механизм [ссылок](/app/glossary/link_to_packet.md).

## Структурный подход

В основе построения *Решений* Loginom лежит методология структурного проектирования - представление алгоритма в виде иерархической структуры блоков. Каждый блок на своем уровне иерархии может быть представлен в виде черного ящика, выполняющего независимую подзадачу. Механизм решения подзадачи внутри черного ящика можно изменить, но в целом *Решение* при этом останется работоспособным и будет выполнять поставленные задачи. Спроектированное таким образом *Решение* имеет четкую, легко читаемую архитектуру. Все это позволяет создавать и сопровождать структурно сложные проекты, а также делегировать решение выделенных подзадач.

Особенностью подобного подхода является **проектирование «сверху вниз»** - от общей постановки задачи к отдельным подзадачам. На первом этапе проектирования описывают решение поставленной задачи, выделяя независимые подзадачи. На следующем аналогично описывают подзадачи, формулируя при этом элементы следующего уровня. Таким образом, на каждом шаге происходит уточнение функций проектируемого *Решения*. Процесс продолжают, пока не доходят до подзадач, алгоритмы решения которых очевидны.

## Механизм повторного использования алгоритмов

Выделение блоков, решающих независимые подзадачи, дает возможность применять их повторно в смежных задачах. Развитием идеи повторного использования ранее созданных алгоритмов является создание библиотек универсальных функций. 

В Loginom инструментом для создания таких функций являются [производные компоненты](/app/glossary/derived_component.md). Создав один раз компонент ABC-анализа, его можно применять как в задаче сегментации товаров, так и в сегментации клиентской базы. Подзадача, решаемая компонентом проверки адресов, может применяться как в очистке данных, так и в задачах скоринга. 

В производных компонентах реализуется **[механизм наследования](/app/glossary/inheritance_redefinition.md)**, преимуществом которого является то, что он позволяет модифицировать созданный пользователем универсальный компонент лишь в одном месте - в библиотеке функций, и эти изменения автоматически произойдут во всех сценариях, где он применяется.
 
Однако, не всегда удается встроить универсальный компонент в конкретный сценарий без внесения в него изменений. При этом изменить его в библиотеке функций нет возможности, поскольку сработает механизм наследования, и это может привести к ошибкам во всех сценариях, где он применяется. Данную задачу решает **[механизм переопределения](/app/glossary/inheritance_redefinition.md)**, позволяющий модифицировать производный компонент только в использующем его сценарии, при этом в библиотеке функций он останется неизменным.

## Декомпозиция

Структура *Решения* может быть представлена в иерархическом виде:


*  **Решение** может состоять из связанных между собой Пакетов - это возможно благодаря тому, что **каждый пакет может предоставлять свои объекты другим пакетам** через механизм [ссылок](/app/glossary/link_to_packet.md);

*  **Пакет** включает в себя Модули - декомпозиция пакета на уровне модулей;

*  **Модуль** - сам по себе не содержит узлов обработки данных, но предоставляет отдельное пространство для Сценариев и [Подключений](/app/integration/connections/start.md) к различным источникам данных;

*  **Сценарий** - содержит последовательность узлов обработки данных. Сценарий может:
    * включать в себя подпрограммы - Подмодели;
    * получать данные от узлов из других сценариев и пакетов через механизм "[Узел-ссылка](/app/processors/control/unit-link.md)";
    * использовать настройки и обученные модели узлов из других сценариев и пакетов через механизм "[Выполнение узла](/app/processors/control/execute_node.md)";
    * использовать готовые алгоритмы обработки данных, созданные в других сценариях и пакетах через механизм "[Производные компоненты](/app/glossary/derived_component.md)".

*  **[Подмодель](/app/processors/control/submodel.md)** - включает в себя другие узлы, предоставляя таким образом отдельное пространство для реализации произвольного алгоритма обработки данных. В сценарии представлена в качестве узла, имеющего заданные пользователем входные и выходные порты. Может содержать в себе иерархию вложенных Подмоделей. На базе Подмодели может быть создан [Производный компонент](/app/glossary/derived_component.md);

## Управление ходом обработки данных

### Последовательность выполнения

В общем случае последовательность выполнения узлов задается соединением их входных и выходных портов. Однако, иногда необходимая последовательность обработки данных не может быть задана таким образом. Например, если необходимо выгрузить данные во внешний источник и следующим действием загрузить уже модифицированные данные из внешнего источника. В этом случае для задания последовательности [применяют служебные порты](/app/glossary/execution_sequence.md) (см. рисунок 1).

![](/media/app/beginning/execution_sequence2.png) 
*Рисунок 1. Использование служебных портов для задания последовательности выполнения узлов*

Loginom предоставляет возможность параллельного выполнения нескольких ветвей сценария. Например, следующие цепочки узлов будут выполнены параллельно (см. рисунок 2):

![](/media/app/beginning/parallel_computing.png) 
*Рисунок 2. Параллельность выполнения веток сценария*

Подобная возможность позволяет сократить время выполнения сценария за счет более полного использования вычислительных мощностей компьютера.


### Цикл

Цикл — управляющая конструкция, предназначенная для организации многократного исполнения набора инструкций. 

Loginom предоставляет возможность использования следующих разновидностей циклов:


*  Цикл со счётчиком – аналог «FOR … TO …»;

*  Цикл с постусловием – аналог «DO … WHILE …»;

*  Цикл по набору данных (групповая обработка) – аналог «FOR EACH».

Использование подмоделей позволяет легко реализовать **вложенность циклов**.

Имеется возможность выполнения циклов **в несколько потоков**, что может существенно сократить время обработки.

Подробности: [компонент "Цикл"](/app/processors/control/cycle.md)
### Условие (ветвление)

Условие — управляющая конструкция, обеспечивающая ветвление алгоритма в зависимости от значения некоторого выражения (аналог SWITCH... CASE...). В зависимости от заданного условия ход выполнения сценария может пойти по одной из возможных веток (см. рисунок 3).

![](/media/app/beginning/condition.png) 
*Рисунок 3. Выполнение одной из веток сценария в зависимости от условия*

Подробности: [компонент "Условие"](/app/processors/control/condition.md)
## Использование переменных

Наряду с наборами данных, представляющих из себя таблицу данных, в Loginom объектом, используемым в вычислениях, может быть переменная - именованное значение одного из возможных [типов данных](/app/glossary/datatypes.md). Для приема и передачи от узла к узлу переменных предусмотрены специализированные порты. Такой порт может принять в качестве входных данных или отдать в качестве выходных несколько переменных. Таким образом от узла к узлу может передаваться список переменных. 

Примеры использования переменных: 

*  переменная в формуле, вычисляющей значение выражения калькулятора. См. узел ["Калькулятор"](/app/processors/transformation/calc.md);

*  переменная в качестве параметра условия ветвления алгоритма.  См. узел ["Условие"](/app/processors/control/condition.md)

см. так же: [Переменные](/app/glossary/variables.md)
### Управляющие переменные

Переменные так же могут быть использованы для того, чтобы задать параметры настроек узлов. Таким образом, настройки узлов могут быть предметом вычисления в ходе выполнения сценария. Это позволяет более гибко реализовывать логику обработки данных. 

Примеры использования управляющих переменных: 

*  переменная может выступать параметром условия фильтрации данных. См. узел ["Фильтр строк"](/app/processors/transformation/row_filter.md);

*  переменная в качестве параметра SQL-запроса при импорте из базы данных, переменная содержит текст SQL-запроса. См. узел ["Импорт из базы данных"](/app/integration/import/bd.md).

см. так же: [Управляющие переменные](/app/glossary/variables/control_variables.md)


